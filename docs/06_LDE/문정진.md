

# 어떻게하면 성능 저하 없으며 제어권을 유지 시킬 수 있을까?

## 9.1 제한적 직접 실행

제한적 직접 실행  
프로그램을 cpu상에서 직접 실행.  
프로그램 실행 -> 프로세스 항목 만드기 -> 메모리에 할당 -> 프로그램 코드 디스크 탑재.

문제점
- 운영체제가 원치않는 일을 하지 않는 다는 것을 어떻게 알 수 있나? 
- 프로그램의 실행을 중단하고 다른 프로세스로 전환을 어떻게 시키나,

## 9.2 문제점 1 제한된 연산

직접 실행 장점  
실행이 빠름 -> 특수한 연산이 필요하면? -> 디스크 입출력 요청 & cpu, 메모리등 자원을 추가할당
-   사용자 모드 (user mode) : 실행되는 코드 할 수 있는 일 제한. 제한 작업 실행을 허용하기 위해서 시스템 콜을 제공함.
-   커널 모드 (kernel mode) : 실행되는 코드는 모든 특수한 명령 포함해 모든 작업 가능.
<br/>

시스템 콜
* 제한 작업 실행 허용  
* 사용자에게 파일 접근  
* 프로세스 생성 제거, 메모리 할당 등 시스템 콜 제공.

trap 명령어
* 시스템 콜을 실행하기 위해 해당 명령어 실행.  
* 해당 명령어는 특권 수준을 커널 모드로 상향.

> 해당 파트가 이해가 안되어, 개인적으로 이해한 바를 써봤습니다. 다른 의견 부탁드려요

- 커널 모드는, 예를 들어 sudo 권한처럼 사용자 모드에서 사용하면 안 되는 명령어를 가지고 있는 것 처럼 느껴짐.  
시스템 콜을 통해 제한된 접근을 가능하게 함.  
시스템 콜 실행을 위해 trap 사용.   
trap으로 명령어가 완료 되면 return-form-trap 호출하여 다시 시스템 콜 형식으로 리턴(?)
> --------------------------------------

* 트랩 테이블  
부팅시 커널은 트랩 테이블 만들고, 이를 통해 시스템 통제.프로그램이 시스템 콜 호출 시  
운영처제는 특정 명렁어를 트랩 핸들러를 통해 위치 전달.  
이를 통해 시스템 콜 및 예외 상황 시 하드웨어가 무슨 일을 야하는지 알 수 있음. 


## 9.3 문제점 2 프로세스 간 전환

직접 실행은 프로세스 간 전환을 할 수 있어야 함.  
cpu 프로세스 실행 중이면 운영체제 실행 중이지 않음(?)

1. 협조 방식 : 시스템 콜 기다리기
    - 프로세스는 운영체제가 다른 작업 실행하게 주기적으로 cpu 포기.
    - 프로세스 시스템 콜 호출해 cpu 제어권 넘김.
    - 비정상적인 행위나 접근할 수 없는 메모리 접근시 트랩 발생 -> 운영체제 cpu 획득
2. 비협조 방식 : 운영체제가 전권 행사
    - 협조 방법에서 프로세스가 무한 루프나 시스템 문제는 컴퓨터 재부팅.
    - 타이머 인터럽트 이용, 인터럽트 발생 시 프로세스 중단되고 인터럽트 핸들러 실행.

## 문맥의 저장과 복원

> 1. 운영체제 제어권 재획득 -> 2. 스케줄러 전환될 프로세스 결정 -> 3. 프로세스 전환 위한 문맥 교환

문맥 교환 : 실행 중인 프로세스 레지스터 값 커널 스택에 저장, 실행 될 프로세스 커널 스택에서 레지스터 값 복원.  
 
1. 프로세스 A 타이머 인터럽트 발생.
2. A 레지스터 커널 스택 저장 후 커널 모드 진입.
3. 타이머 인터럽트 핸들러에서 운영체제가 프로세스 B로 전환 결정

## 9.4 병행성 걱정

시스템 콜 처리 중 타이머 인터럽트 발생했다면?  
 -> 인터럽트를 처리하는 동안 인터럽트 불능화!<br/>
  -> 락(자료 구조 동시 접근 방지)
 
 인터럽트 불능화란? 인터럽트가 처리 되고 있을 때, 다른 인터럽트들이 cpu에 전달 되지 않음.  
 오랫동안 불능화 시킬 시 인터럽트 놓치며 기술적 좋지 않음.
